import pickle
from utils.config import *

def getEdgeCount(cluster_size_dic):
   '''Calculate the number of edges for each cluster
   '''
   edge_count = 0
   for _,v in cluster_size_dic.items():
      edge_count += v*(v-1) / 2
   return edge_count

def remove_singleton_df(df, attr):
    '''Remove groups containing one record only from DataFrame.

       Input:
       - df: DataFrame
       - attr: column name used as group ID 

       Output:
       - Cluster DataFrame without singletons
    '''
    value_counts = df[attr].value_counts()
    index = value_counts.index[value_counts == 1].tolist()
    filtered_df = df[~df[attr].isin(index)]
    return filtered_df

def load_bf_collection(threshold, year, max_age, hash_num):
  """Load encoded clusters given specified settings: threshold, year, max_age, hash_num

     Output:
     Two dictionaries, key is the cluster IDs and value is the encoded BF
     - sensitive_bf_dict: dictionary, encoded clusters from the sensitive dataset
     - public_bf_dict: dictionary, encoded clusters from the public dataset

  """
  
  sensitive_encoded_pickle = open(s_encoded_path, "rb")
  sensitive_bf_dict = pickle.load(sensitive_encoded_pickle)[(year, threshold, max_age, hash_num)]

  public_encoded_pickle = open(p_encoded_path, "rb")
  public_bf_dict = pickle.load(public_encoded_pickle)[(year, max_age, hash_num)]

  return sensitive_bf_dict, public_bf_dict


def dice_bf_sim(bf1, bf2):
  """Calculate the Dice Similarity between the two given Bloom filter vectors. 
     Dice similarity is calculated between two Bloom filters A and B as 
     Dice similarity (A,B) = 2 x number of common 1 bit positions of A and B
                                -----------------------------------------------
                                number of 1 bit positions of A + 
                                                 number of 1 bit positions of B

     Parameter Description:
       - bf1  The first vector.
       - bf2  The second vector.

     This method returns an output,
       - bf_sim  The dice similarity between the Bloom filter pair.
  """

  assert len(bf1) == len(bf2)

  # Count the number of bit positions set to 1 
  num_ones_bf1 = bf1.count(1) 
  num_ones_bf2 = bf2.count(1) 
  
  # Perform the AND operation between two BFs to get the common bit positions set to 1
  bf_common = bf1 & bf2 

  # Count the number of 1 bit positions
  num_common_ones = bf_common.count(1) 

  bf_sim = (2 * num_common_ones) / (float(num_ones_bf1) + float(num_ones_bf2))

  return bf_sim

# -----------------------------------------------------------------------------
# Function for comparing every pair of Bloom filters
# -----------------------------------------------------------------------------

def compareBF(bf_dict_A, bf_dict_B):
  """Build a similarity dictionary with pair of clusters from the two given dataset. Candidate pairs are generated by pairing each cluster from data set A with all the clusters from dataset B. For each candidate pair, a similarity is computed.
     Input:
       - bf_dict_A, bf_dict_B: dictionary, key is the cluster ID, value is the encoded BF
     Output:
       - sim_bf_dict: A similarity dictionary with one similarity value per compared pair.
  """

  sim_bf_dict = {}  
  for cluster_idA in bf_dict_A.keys():

    # Get the encoded vector from dataset A
    bf_A = bf_dict_A[cluster_idA]  

    # Get the encoded vector from dataset B
    for cluster_B in bf_dict_B.keys():

      bf_B = bf_dict_B[cluster_B] 

      # Compute the similarity between two Vectors
      sim = dice_bf_sim(bf_A, bf_B)

      # Save the similarity of the compared pair to the dictionary
      sim_bf_dict[(cluster_idA, cluster_B)] = sim

  print('Compared %d Bloom filter pairs' % (len(sim_bf_dict)))

  return sim_bf_dict

